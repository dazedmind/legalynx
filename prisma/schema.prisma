generator client {
  provider = "prisma-client-js"
  // output   = "../src/generated/prisma"
  output   = "../node_modules/.prisma/client"
}
// generator py {
//   provider             = "prisma-client-py"
//   recursive_type_depth = 5
// }

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String    @id @default(uuid())
  name              String?
  email             String    @unique
  password          String
  job_title         String?   @map("job_title")
  profile_picture   String?   @map("profile_picture")
  status            UserStatus @default(ACTIVE)
  email_verified    Boolean   @default(false) @map("email_verified")
  created_at        DateTime  @default(now()) @map("created_at")
  updated_at        DateTime  @updatedAt @map("updated_at")
  last_login_at     DateTime? @map("last_login_at")
  failed_login_attempts Int   @default(0) @map("failed_login_attempts")
  account_locked_until  DateTime? @map("account_locked_until")

  // Relationships
  documents          Document[]
  chat_sessions      ChatSession[]     @relation("UserChatSessions")
  security_logs      SecurityLog[]     @relation("UserSecurityLogs")
  sessions           Session[]
  verification_tokens VerificationToken[] @relation("UserVerificationTokens")
  token_usage_logs   TokenUsageLog[]
  password_reset_tokens PasswordResetToken[] @relation("UserPasswordResetTokens")

  // One-to-one relationship with Subscription
  subscription       Subscription?     @relation("UserSubscription")
  folders           Folder[]

  // One-to-one relationship with UserSettings
  user_settings      UserSettings?     @relation("UserUserSettings")
  invoices            Invoice[]     @relation("UserInvoices")

  @@map("users")
}

model Subscription {
  id              String    @id @default(cuid())
  user_id         String    @unique @map("user_id") // Make unique for one-to-one
  tokens_used     Int       @default(0) @map("tokens_used")
  token_limit     Int       @map("token_limit")
  storage         Int       @default(0) @map("storage")
  storage_used    Int       @default(0) @map("storage_used")
  billing_date    DateTime?  @map("billing_date")
  days_remaining  Int       @map("days_remaining")
  
  // Subscription details
  plan_type       SubscriptionStatus @default(BASIC) @map("plan_type")
  price           Float?    @map("price") // Monthly price
  currency        String    @default("PHP") @map("currency")
  is_active       Boolean   @default(true) @map("is_active")
  auto_renew      Boolean   @default(true) @map("auto_renew")
  
  // Payment information
  payment_method  String?   @map("payment_method") // "card", "paypal", etc.
  last_four_digits String?  @map("last_four_digits") // Last 4 digits of card
  payment_provider String?  @map("payment_provider") // "stripe", "paypal", etc.
  external_subscription_id String? @map("external_subscription_id") // Stripe/PayPal subscription ID
  
  // Timestamps
  created_at      DateTime  @default(now()) @map("created_at")
  updated_at      DateTime  @updatedAt @map("updated_at")
  cancelled_at    DateTime? @map("cancelled_at")
  tokens_reset_date DateTime? @map("tokens_reset_date")

  // Relationship back to User
  user User @relation("UserSubscription", fields: [user_id], references: [id], onDelete: Cascade)
  last_invoice_id       String?   @map("last_invoice_id")
  last_invoice_sent_at  DateTime? @map("last_invoice_sent_at")
  @@map("subscriptions")
}

model TokenUsageLog {
  id           String    @id @default(cuid())
  user_id      String    @map("user_id")
  tokens_used  Int       @map("tokens_used")
  operation    String    @map("operation") // "chat", "upload", "search"
  created_at   DateTime  @default(now()) @map("created_at")
  
  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)
  
  @@index([user_id, created_at])
  @@map("token_usage_logs")
}

model UserSettings {
  id              String    @id @default(cuid())
  user_id         String    @unique @map("user_id") // Make unique for one-to-one
  
  // File Management Settings
  auto_rename_files Boolean @default(false) @map("auto_rename_files")
  file_naming_format FileNamingFormat @default(ORIGINAL) @map("file_naming_format")
  file_retention_days Int?  @map("file_retention_days") // null = never delete, 7, 30, 60, 90
  auto_delete_files Boolean @default(false) @map("auto_delete_files")
  
  // Security Settings
  two_factor_enabled Boolean @default(false) @map("two_factor_enabled")
  two_factor_secret String?   @map("two_factor_secret")
  
  // UI/UX Preferences
  theme             String    @default("light") @map("theme") // "light", "dark", "auto"
  date_format       String    @default("MM/DD/YYYY") @map("date_format")
  
  // Usage Tracking
  last_settings_update DateTime @default(now()) @map("last_settings_update")
  
  // Timestamps
  created_at        DateTime  @default(now()) @map("created_at")
  updated_at        DateTime  @updatedAt @map("updated_at")

  // Relationship back to User
  user User @relation("UserUserSettings", fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model Document {
  id                String         @id @default(cuid())
  file_name         String         // S3 key when INDEXED, original name when UPLOADED
  original_file_name String
  file_path         String         // S3 URL when INDEXED, empty when UPLOADED
  s3_key           String?         // S3 object key (only when INDEXED)
  file_size         Int
  mime_type         String
  status            DocumentStatus @default(UPLOADED)
  page_count        Int?
  processing_started_at DateTime?   // When RAG processing started
  processing_completed_at DateTime? // When RAG processing completed
  s3_uploaded_at    DateTime?      // When uploaded to S3
  owner_id          String
  uploaded_at       DateTime       @default(now())
  updated_at        DateTime       @updatedAt
  
  // Relations
  owner            User @relation(fields: [owner_id], references: [id], onDelete: Cascade)
  chat_sessions    ChatSession[] @relation("DocumentChatSessions")
  
    // Add folder relationship
  folder_id     String?  @map("folder_id")
  folder        Folder?  @relation(fields: [folder_id], references: [id], onDelete: SetNull)

  // Indexes for performance
  @@index([owner_id, status])
  @@index([status, updated_at])
  @@map("documents")
}

model Folder {
  id          String   @id @default(uuid())
  name        String
  path        String   // Full path like "folder1/subfolder2"
  parent_id   String?  @map("parent_id")
  owner_id    String   @map("owner_id")
  created_at  DateTime @default(now()) @map("created_at")
  updated_at  DateTime @updatedAt @map("updated_at")
  
  // Self-referential relationship for nested folders
  parent      Folder?   @relation("FolderHierarchy", fields: [parent_id], references: [id], onDelete: Cascade)
  children    Folder[]  @relation("FolderHierarchy")
  
  // Relations
  owner       User      @relation(fields: [owner_id], references: [id], onDelete: Cascade)
  documents   Document[]
  
  // Constraints
  @@unique([owner_id, parent_id, name]) // Prevent duplicate folder names in same directory
  @@index([owner_id, parent_id])
  @@map("folders")
}

model ChatSession {
  id          String        @id @default(uuid())
  title       String?       
  user_id     String        @map("user_id")
  user        User          @relation("UserChatSessions", fields: [user_id], references: [id], onDelete: Cascade)
  document_id String        @map("document_id")
  document    Document      @relation("DocumentChatSessions", fields: [document_id], references: [id], onDelete: Cascade)
  is_saved    Boolean       @default(false) @map("is_saved")
  created_at  DateTime      @default(now()) @map("created_at")
  updated_at  DateTime      @updatedAt @map("updated_at")
  
  messages    ChatMessage[] @relation("SessionMessages")
    
  @@map("chat_sessions")
}

model ChatMessage {
  id             String      @id @default(uuid())
  session_id     String      @map("session_id")
  session        ChatSession @relation("SessionMessages", fields: [session_id], references: [id], onDelete: Cascade)
  role           MessageRole // USER or ASSISTANT
  content        String      @db.Text
  source_nodes   Json?       @map("source_nodes") // Retrieved sources info
  tokens_used    Int?        @map("tokens_used")
  created_at     DateTime    @default(now()) @map("created_at")
  
  // Branching support - stores alternative conversation paths
  branches       Json?       @map("branches") // Array of MessageBranch objects (only for USER messages)
  current_branch Int?        @map("current_branch") // Currently displayed branch index
  
  @@map("chat_messages")
}

model SecurityLog {
  id         String          @id @default(uuid())
  user_id    String          @map("user_id")
  user       User            @relation("UserSecurityLogs", fields: [user_id], references: [id], onDelete: Cascade)
  action     SecurityAction
  details    String?
  ip_address String?         @map("ip_address")
  user_agent String?         @map("user_agent")
  created_at DateTime        @default(now()) @map("created_at")
  
  @@index([user_id, created_at])
  @@map("security_logs")
}

model VerificationToken {
  id         String   @id @default(uuid())
  email      String
  key        String
  token      String   @unique
  user_id    String?  @map("user_id")
  user       User?    @relation("UserVerificationTokens", fields: [user_id], references: [id], onDelete: Cascade)
  type       TokenType @default(EMAIL_VERIFICATION)
  expires_at DateTime @map("expires_at")
  used       Boolean  @default(false)
  created_at DateTime @default(now()) @map("created_at")
  
  @@map("verification_tokens")
}

model PasswordResetToken {
  id         String   @id @default(uuid())
  user_id    String   @map("user_id")
  user       User?    @relation("UserPasswordResetTokens", fields: [user_id], references: [id], onDelete: Cascade)
  token      String   @unique
  used       Boolean  @default(false)
  expires_at DateTime @map("expires_at")
  created_at DateTime @default(now()) @map("created_at")
  
  @@map("password_reset_tokens")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions") // Use snake_case table name
}

// Add these models to your existing schema.prisma file

model Invoice {
  id                    String        @id @default(cuid())
  invoice_number        String        @unique @map("invoice_number")
  user_id               String        @map("user_id")
  plan_type             SubscriptionStatus @map("plan_type")
  billing_cycle         BillingCycle  @map("billing_cycle")
  amount                Float         @map("amount") // Using Float to match your subscription price field
  currency              String        @default("PHP") @map("currency")
  subscription_id       String?       @map("subscription_id") // Reference to external subscription ID
  paypal_transaction_id String?       @map("paypal_transaction_id")
  status                InvoiceStatus @default(SENT) @map("status")
  email_sent_to         String        @map("email_sent_to")
  sendgrid_message_id   String?       @map("sendgrid_message_id")
  
  // Timestamps
  created_at            DateTime      @default(now()) @map("created_at")
  updated_at            DateTime      @updatedAt @map("updated_at")
  sent_at               DateTime?     @map("sent_at")
  viewed_at             DateTime?     @map("viewed_at")
  
  // Relationships
  user                  User          @relation("UserInvoices", fields: [user_id], references: [id], onDelete: Cascade)
  invoice_items         InvoiceItem[] @relation("InvoiceItems")
  
  // Indexes for performance
  @@index([user_id, created_at])
  @@index([invoice_number])
  @@index([subscription_id])
  @@index([status])
  @@map("invoices")
}

model InvoiceItem {
  id          String  @id @default(cuid())
  invoice_id  String  @map("invoice_id")
  description String  @db.Text
  quantity    Int     @default(1)
  unit_price  Float   @map("unit_price")
  total       Float   @map("total")
  
  // Timestamps
  created_at  DateTime @default(now()) @map("created_at")
  
  // Relationship
  invoice     Invoice @relation("InvoiceItems", fields: [invoice_id], references: [id], onDelete: Cascade)
  
  @@index([invoice_id])
  @@map("invoice_items")
}

// Add these enums to your existing enums section

enum InvoiceStatus {
  SENT
  FAILED
  DELIVERED
  VIEWED
}

enum BillingCycle {
  MONTHLY
  YEARLY
}


enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum SubscriptionStatus {
  BASIC
  STANDARD
  PREMIUM
}

enum DocumentStatus {
  UPLOADED    // Initial upload, not processed yet
  PROCESSING  // Currently being processed by RAG pipeline
  PROCESSED   // RAG processing complete, ready for S3 upload
  INDEXED     // Uploaded to S3 and fully ready for use
  FAILED      // Processing or upload failed
  TEMPORARY   // Session-only document (not saved to account)
}

enum MessageRole {
  USER
  ASSISTANT
}

enum FileNamingFormat {
  ORIGINAL
  ADD_TIMESTAMP
  ADD_CLIENT_NAME
}

enum SecurityAction {
  LOGIN
  LOGOUT
  PASSWORD_CHANGE
  EMAIL_CHANGE
  PROFILE_UPDATE
  TWO_FACTOR_ENABLED
  TWO_FACTOR_DISABLED
  TWO_FACTOR_LOGIN
  DOCUMENT_UPLOAD
  DOCUMENT_DELETE
  DOCUMENT_DOWNLOAD
  CHAT_SAVE
  CHAT_DELETE
  FAILED_LOGIN
  ACCOUNT_LOCKED
  ACCOUNT_UNLOCKED
}